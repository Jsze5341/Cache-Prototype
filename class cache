#32 bit address
#2 set 4 way associative
#512 (64 bytes x 8 blocks) bytes
#Cache Size = 512
#Block Size = 64
#Cache Blocks = 8

class cache:
    lrutimer = 0
    elements = 4 #[index, valid, tag, data]
    block_number = 8
    set_blocks = 4
    cache_block = [[0 for i in range(elements)] for j in range(block_number)] #2D array with elements as row, blocks as column
    cache_set0 = [[0 for i in range(elements)] for j in range(set_blocks)] #2D array with elements as row, set_blocks as column
    cache_set1 = [[0 for i in range(elements)] for j in range(set_blocks)] #2D array with elements as row, set_blocks as column
    index = cache_block[0]
    valid = cache_block[1]
    tag = cache_block[2]
    data = cache_block[3]
    
    def __init__(self, data, instructions):
        # Member Variables:
        self.__instructions = instructions
        self.__index = cache_block[0]
        self.__valid = cache_block[1]
        self.__tag = cache_block[2]
        self.__ data = cache_block[3]
        self.__lrutimer = 0
        self.__cache_block = [[0 for i in range(elements)] for j in range(block_number)] #2D array with elements as row, blocks as column
        self.__cache_set0 = [[0 for i in range(elements)] for j in range(set_blocks)] #2D array with elements as row, set_blocks as column
        self.__cache_set1 = [[0 for i in range(elements)] for j in range(set_blocks)] #2D array with elements as row, set_blocks as column
        self.__cache_lru = [[0 for i in range(elements)] for j in range(lrutimer)] #2D array with elements as row, lrutimer as column

    def tlb(virtual_address):
        tag = virtual_page_number
        if hit:
            writethrough(self)
        else:
            #tag -> tlb	
	    tlb(tag)
            memory.TLB_miss(virtual_address)
            #Return physical address
	    
    def __read(data):
        if block() and tag == 
            tag == instruction
            valid == True
            block.data[offset]
        else
            memory.cache_miss(address)

            #Return void

    def __offset(physical_address):
	offset = physical_address[-1] + physical_address[-2] + physical_address[-3] #3 bytes
	
    def __index(physical_address):
    	index = physical_address[-4] #1 byte
	
    def __tag(physical_address):
    	tag = physical_address[0:28] #Remaining bytes
   
    def block():
        #number_of_blocks = index
        #512 bytes / 64 bytes
        #2 sets, 4 way associative
        
        #blocks[8] = {000,001,010,011,100,101,110,111}
        #set0[4] = {000,001,010,011}
        #set1[4] = {100,101,110,111}
        
        for i in range(0,8):
            binary = bin(i)
            cache_block[i][0] = binary #Block indices
            #First set indices
            if str(binary[0]) = 0:
                set0[i][0] = binary
            #Second set indices
            elif str(binary[0]) = 1:
                set1[i][0] = binary
                
	
    def block_search(physical_address):
        #Searches for available blocks
        block()
	tag = cache.__tag(physical_address)
        #Benched Idea 1: Counts blocks
        for i in range(0,8):
            if cache_block{index, tag[i]} == cache_block{index,tag[i+1]} and valid:
                #cache hit
                cache.__store
                lru()
            else: 
                #cache miss
                __valid == True
                cache.__store
                lru()
        
        #Idea 2: Counts through the 4 blocks of Sets 0 and 1
        for i in range(0,4):
            if i = 0:
                if cache_set0[2][i] = tag and cache_set[1][i] = 1:
                    #cache hit
                    cache.__store(physical_address)
		    writethrough(physical_address)
                    lru()
	        if cache_set1[2][i] = tag and cache_set[1][i] = 1:
		    #cache hit
                    cache.__store(physical_address)
		    writethrough(physical_address)
                    lru()
                else: 
                    #cache miss
                    writemiss(physical_address)
                    lru()

    def __store(physical_address):
        block_search(physical_address)
        
        if block and cache_block[1] == 0: #cache_block[1] checks for validity
            new block = block
        if block and cache_block[1] == 1:
            __writemiss(physical_address)
        pass
        #Return void
	
    def lru():
        #Every 8th cache element gets removed
        if cache_lru[1] % 8 == 0:
            cache_block[0] = cache_lru[0]
            cache_block.remove[0]
	    cache_lru[1] += 1
        
        else:
            cache_lru[1] += 1

    def writethrough(physical_address):
        #If the tags of two addresses match
        #and first address' tag is in a block
        #loads second address into the cache block
        #and memory
	tag = cache.__tag(physical_address)
	for i in range(0,4)
            if cache_set0[i][2] = tag:
               cache_set0[i][2] #physical address of tag2 -> cache block
                #physical address of tag2 -> memory
            else:
                memory.cache_miss(page_number, page_offset, process_physical_address)
        
        memory.write(address)
        #Writes into memory
        
    def writemiss(physical_address):
        index = cache.__index(physical_address)
        tag = cache.__tag(physical_address)

	for i in range (0,4)
            if cache_set0[i][0] != index and cache_set0[i][2] != tag: #if index and cache are not found in set0
                memory.write(cache_set0[i][3]) # Writes data from given index in cache_set0
	    if cache_set1[i][0] != index and cache_set0[i][2] != tag: #if index and cache are not found in set1
                memory.write(cache_set1[i][3]) # Writes data from given index in cache_set1
            
        #Load block into memory and not cache
        
 class block:
    index = 0
    valid = False
    tag = 0
    data1 = 0
    data2 = 0
    data3 = 0
    data4 = 0
    lrutimer = 0
    elements = 4 #[index, valid, tag, data]
    block_number = 8
    set_blocks = 4
    cache_block = [[0 for i in range(elements)] for j in range(block_number)] #2D array with elements as row, blocks as column
    cache_set0 = [[0 for i in range(elements)] for j in range(set_blocks)] #2D array with elements as row, set_blocks as column
    cache_set1 = [[0 for i in range(elements)] for j in range(set_blocks)] #2D array with elements as row, set_blocks as column
